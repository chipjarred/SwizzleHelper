# SwizzleHelper

SwizzleHelper is a Swift Package that helps make swizzling (aka "monkey patching") Objective-C methods easier in Swift.

Swizzling is a practice that is sometimes used in Objective-C to change out the implementations of methods with another to hook functionality into classes that didn't provide for them.  Normally the replacement implementation calls the previous one, either before or after doing it's own thing, in order to preserve the existing functionality.  It's generally not done in Swift, and is kind of an extreme method even in Objective-C, but it can be a useful and powerful tool.  For example, I used it in combination with an extenson on `NSView` in my CustomToolTip package to add the ability to attach to any `NSView`  customized tool tips that can contain any `NSView` as its content without the need to subclass anything or wrap existing objects in a special "tool tippable" object.  The effect is you can just assign the tool tip view to a `customToolTIp` property just like you assign a `String` to the standard `toolTip` that `NSView` supports out of the box.

This only works for `@objc` methods, which means you can't swizzle Swift-native methods (well, you kind of can, but that involves some especially wicked and tricky manipulation involving the dynamic linker).  Another thing to note is that when you call a method directly in Swift, it might not go through the Obj-C messaging mechanism, which means that if you swizzle `foo`'s implementation with another method called `bar`, when you call `foo` in Objective-C, it will actually call `bar`, but when you call `foo` in Swift, it might very well call `foo` anyway.   That's because the compiler often can resolve the exact method that should be called at compile time, but swizzling is a runtime thing.  To get guarantee same behavior in Swift that you get in Objective-C, you'd have to use `NSObject`'s `performSelector` methods.  For this reason, it's a good idea to limit swizzling to methods that are called by AppKit or UIKit rather than directly by your code, for example methods of `NSResponder` or `NSView` that are called to reponde to events or changes in layout.  For example, CustomToolTip swizzles `updateTrackingAreas`, `mouseEntered`, `mouseExited` and `mouseMoved`.  Everything thing it does is done in pure native Swift methods.

I dont want to encourage anyone to go to swizzling as a first solution, because you are messing with the "natural order" of things when you do this.  It's easy to break things in a way that's hard to debug.  While useful, I'm not trying to promote doing that, so I'm not providing "how-to" documentation here in this README.  That said,  The code is pretty thoroughly documented with doc comments.  So if as a last resort, or just out of personal interest, you decide to give it a try, I'll point you to the `replaceMethod(_:with:)` and `callReplacedMethod(for:)` methods in the `NSObject+Swizzling.swift` file.  Before you do, spend some time reading the various articles on-line about swizzling, which generally are all about Objective-C, but the principle is exactly the same.  Also understand that most wide-spread way to do it also subtly wrong.  I recommend putting this [blog](https://blog.newrelic.com/engineering/right-way-to-swizzle/) on your reading list to understand why.

The current state of this package is pretty much just what I needed for CustomToolTip.  It only handles forwarding to replaced method implementations that take either no parameters or a single `NSObject` parameter and that don't return anything.  I'll expand that as I have need.

If this repo helps you get your swizzling to work, and you find that for your use case you had to add forwarding calls or anything else directly related to swizzling, please consider contributing that part of your code to help the next programmer.  While we shouldn't promote swizzling as a "go to" solution, for those who must, we can at least assemble what's needed to do it correctly and reliably in Swift, and in the process make the world a bit less buggy.
